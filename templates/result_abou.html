<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap.min.css">
</head>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/result_abou.css') }}">
    <title> Tableau</title>
</head>
<body>
 
  
    <div class="container">

        <div class="header">
        Nom de l'indicateur: Effectif de la population
        </div>



        <div id="table-container2"></div>

  
        <div class="container-flex">
            <div class="dimensions">
                <h2>Niveaux de désagrégations</h2>
                <ul id="dimension-list" ondragover="handleDragOver(event)" ondrop="handleReturnToDimensions(event)">
                    {% for dimension in dimensions %}
                        <li draggable="true" data-id="{{ dimension }}">{{ dimension }}</li>
                    {% endfor %}
                </ul>
                
            </div>
            <div class="tableaux">
                <div class="buttons">
                    <form method="GET" action="/abou">
                        <button type="submit" class="btn btn-primary">Générer le tableau</button>
                    </form>
                    <button class="btn btn-primary">Télécharger en Excel</button>
                    <button class="btn btn-primary">Télécharger en CSV</button>
                   
                    <button onclick="window.location.href='#';" class="btn btn-primary">Voir Metadonnées</button>
                </div>
                <div class="dropzone" id="dropzone1">
                    <p>Ligne</p>
                </div>
                <div class="dropzone" id="dropzone2">
                    <p class="vertical">Colonne</p>
                </div>
                <!-- Ici doit s'afficher le tableau des données -->
                <div class="table-container">
                    <h3>Résultat</h3>
                    <input type="text" id="filter-input" placeholder="Filtre sur ligne..">
                    <div>{{ ma_table_html | safe }}</div>
                </div>
            </div>
        </div>
    </div>     
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const filterInput = document.getElementById('filter-input');
            const table = document.querySelector('.table-container table');
            const rows = table.getElementsByTagName('tr');
    
            filterInput.addEventListener('input', function() {
                const filter = filterInput.value.toLowerCase();
                for (let i = 1; i < rows.length; i++) { // Commence à 1 pour ignorer l'en-tête
                    const firstCell = rows[i].cells[0]; // Sélection de la première cellule (index)
                    if (firstCell) {
                        const textValue = firstCell.textContent || firstCell.innerText;
                        // Affiche ou masque la ligne en fonction de la correspondance
                        rows[i].style.display = textValue.toLowerCase().includes(filter) ? '' : 'none';
                    }
                }
            });
        });
    </script>
    
   
    <script>
        // JavaScript pour la gestion du drag-and-drop optimisé
        document.addEventListener('DOMContentLoaded', () => {
            const dimensionItems = document.querySelectorAll('.dimensions li');
            const dropzones = document.querySelectorAll('.dropzone');
            const dimensionList = document.getElementById('dimension-list');
            
            // Initialisation des événements pour les éléments de la liste de dimensions
            dimensionItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
            });
            
            // Initialisation des événements pour les zones de drop
            dropzones.forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('drop', handleDrop);
                zone.addEventListener('dragleave', handleDragLeave);
            });
            
            // Fonctions de gestion du drag-and-drop
            function handleDragStart(event) {
                event.dataTransfer.setData('text/plain', event.target.dataset.id);
                event.target.classList.add('dragging');
            }
    
            function handleDragOver(event) {
                event.preventDefault();
                if (!event.target.classList.contains('dropzone')) return;
                event.target.classList.add('hovered');
            }
    
            function handleDrop(event) {
                event.preventDefault();
                const data = event.dataTransfer.getData('text/plain');
                const dropzone = event.target.closest('.dropzone');
                
                // Éviter le double ajout dans une zone
                if ([...dropzone.querySelectorAll('.dimension-item')].some(item => item.dataset.id === data)) return;
                
                // Création de l'élément dans la zone de drop
                const newElement = createDimensionElement(data);
                dropzone.appendChild(newElement);
                
                // Retrait de l'élément original de la liste principale
                removeElementFromList(data);
                
                togglePlaceholderVisibility(dropzone);
                event.target.classList.remove('hovered');
            }
    
            function handleDragLeave(event) {
                if (event.target.classList.contains('dropzone')) {
                    event.target.classList.remove('hovered');
                }
            }
    
            function handleDragEnd(event) {
                const dropzone = event.target.closest('.dropzone');
                if (!dropzone) {
                    addElementBackToList(event.target.dataset.id);
                    event.target.remove();
                }
                togglePlaceholderVisibility(dropzone);
                event.target.classList.remove('dragging');
            }
    
            function createDimensionElement(data) {
                const element = document.createElement('div');
                element.classList.add('dimension-item');
                element.textContent = data;
                element.setAttribute('draggable', 'true');
                element.dataset.id = data;
                element.addEventListener('dragstart', handleDragStart);
                element.addEventListener('dragend', handleDragEnd);
                return element;
            }
    
            function removeElementFromList(data) {
                const originalElement = dimensionList.querySelector(`li[data-id='${data}']`);
                if (originalElement) originalElement.remove();
            }
    
            function addElementBackToList(data) {
                if (![...dimensionList.querySelectorAll('li')].some(el => el.dataset.id === data)) {
                    const li = document.createElement('li');
                    li.textContent = data;
                    li.setAttribute('draggable', 'true');
                    li.dataset.id = data;
                    li.addEventListener('dragstart', handleDragStart);
                    dimensionList.appendChild(li);
                }
            }
    
            function togglePlaceholderVisibility(dropzone) {
                const placeholder = dropzone.querySelector('p');
                if (dropzone.querySelectorAll('.dimension-item').length > 0) {
                    placeholder.style.display = 'none';
                } else {
                    placeholder.style.display = 'block';
                }
            }

            // Fonction pour ajouter des capacités de filtrage interactif
        function addTableFilters() {
            const table = document.querySelector('#table-container2 table');
            if (table) {
                const headers = table.querySelectorAll('th');
                headers.forEach(header => {
                    const input = document.createElement('input');
                    input.setAttribute('type', 'text');
                    input.setAttribute('placeholder', `Filtrer ${header.textContent}`);
                    input.style.width = '100%';
                    input.style.marginBottom = '5px';

                    header.appendChild(input);

                    input.addEventListener('input', () => {
                        const filterValue = input.value.toLowerCase();
                        const rows = table.querySelectorAll('tbody tr');
                        rows.forEach(row => {
                            const cell = row.querySelector(`td:nth-child(${[...headers].indexOf(header) + 1})`);
                            if (cell && cell.textContent.toLowerCase().includes(filterValue)) {
                                row.style.display = '';
                            } else {
                                row.style.display = 'none';
                            }
                        });
                    });
                });
            }
        }
    
            // Nouvelle fonction pour envoyer les dimensions sélectionnées à Flask
            async function saveDimensions() {
                const rowDimensions = [...document.querySelectorAll('#dropzone1 .dimension-item')].map(item => item.dataset.id);
                const columnDimensions = [...document.querySelectorAll('#dropzone2 .dimension-item')].map(item => item.dataset.id);
    
                try {
                    const response = await fetch('/save_dimensions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            rowDimensions,
                            columnDimensions
                        }),
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ! Statut : ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Dimensions sauvegardées:', data);
                    
                    // Insérer le HTML dans le conteneur
                    if (data.html) {
                        document.getElementById('table-container2').innerHTML = data.html;
                    } else {
                        console.warn('La réponse ne contient pas de propriété html.');
                    }
                } catch (error) {
                    console.error('Erreur lors de la sauvegarde des dimensions:', error);
                }
            }
    
            // Appel de la fonction saveDimensions après chaque changement de dimensions
            dropzones.forEach(zone => {
                zone.addEventListener('drop', saveDimensions);
            });
        });


          
    </script>
</body>
</html>
